//+build ignore

/*
 * Copyright 2019, EnMasse authors.
 * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).
 */

package main

import (
	"flag"
	"fmt"
	"log"
	"os"
	"strings"
	"text/template"
	"time"
)

func main() {

	var global = flag.Bool("global", false, "Globally scoped resource")
	flag.Parse()

	name := flag.Args()[0]
	clientInterface := flag.Args()[1]
	clientPackage := flag.Args()[2]
	typePackage := flag.Args()[3]

	f, err := os.Create(fmt.Sprintf("resource_watcher_%s.go", strings.ToLower(name)))
	die(err)
	defer f.Close()

	var plural string
	if strings.HasSuffix(name, "s") {
		plural = name + "es"
	} else {
		plural = name + "s"
	}

	packageTemplate.Execute(f, struct {
		Timestamp       time.Time
		Name            string
		NamePlural      string
		ClientPackage   string
		ClientInterface string
		TypePackage     string
		Global          bool
	}{
		Timestamp:       time.Now(),
		Name:            name,
		NamePlural:      plural,
		ClientInterface: clientInterface,
		ClientPackage:   clientPackage,
		TypePackage:     typePackage,
		Global:          *global,
	})
}

func die(err error) {
	if err != nil {
		log.Fatal(err)
	}
}

var packageTemplate = template.Must(template.New("").Parse(
	`/*
 * Copyright 2019, EnMasse authors.
 * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).
 */

// Code generated by go generate; DO NOT EDIT.

package watchers

import (
	"fmt"
	tp "{{ .TypePackage }}"
	cp "{{ .ClientPackage }}"
	"github.com/enmasseproject/enmasse/pkg/consolegraphql/cache"
	"k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/watch"
	"k8s.io/client-go/rest"
	"log"
	"reflect"
)

type {{ .Name }}Watcher struct {
	Namespace       string
	cache.Cache
	ClientInterface cp.{{ .ClientInterface }}
	watching        chan struct{}
    watchingStarted bool
	stopchan        chan struct{}
	stoppedchan     chan struct{}
}

func (kw *{{ .Name }}Watcher) Init(c cache.Cache, cl interface{}) error {
	client, ok := cl.(cp.{{ .ClientInterface }})
	if !ok {
		return fmt.Errorf("unexpected type %T", cl)
	}
	kw.Cache = c
	kw.ClientInterface = client
	kw.watching = make(chan struct{})
	kw.stopchan = make(chan struct{})
	kw.stoppedchan = make(chan struct{})
	return nil
}

func (kw *{{ .Name }}Watcher) Watch() error {
	go func() {
		defer close(kw.stoppedchan)
		defer func() {
			if !kw.watchingStarted {
				close(kw.watching)
			}
		}()
		resource := kw.ClientInterface.{{ .NamePlural }}({{if not .Global }}kw.Namespace{{end}})
		log.Printf("{{ .Name }} - Watching")
		running := true
		for running {
			err := kw.doWatch(resource)
			if err != nil {
				log.Printf("{{ .Name }} - Restarting watch")
			} else {
				running = false
			}
		}
		log.Printf("{{ .Name }} - Watching stopped")
	}()

	return nil
}

func (kw *{{ .Name }}Watcher) NewClientForConfig(config *rest.Config) (interface{}, error) {
	return cp.NewForConfig(config)
}

func (kw *{{ .Name }}Watcher) AwaitWatching() {
	<-kw.watching
}

func (kw *{{ .Name }}Watcher) Shutdown() {
	close(kw.stopchan)
	<-kw.stoppedchan
}

func (kw *{{ .Name }}Watcher) doWatch(resource cp.{{ .Name }}Interface) error {
	resourceList, err := resource.List(v1.ListOptions{})
	if err != nil {
		return err
	}

	curr, err := kw.Cache.GetMap("{{ .Name }}/", cache.UidKeyAccessor)

	var added = 0
	var updated = 0
	var unchanged = 0
	for _, res := range resourceList.Items {
		copy := res.DeepCopy()
		kw.updateKind(copy)

		if val, ok := curr[copy.UID]; ok {
			if !reflect.DeepEqual(val, copy) {
				err = kw.Cache.Add(copy)
				updated++
				if err != nil {
					return err
				}
			} else {
				unchanged++
			}
			delete(curr, copy.UID)
		} else {
			kw.Cache.Add(copy)
			added++
		}

		kw.Cache.Add(copy)
	}

	// Now remove any stale
	for _, stale := range curr {
		err = kw.Cache.Delete(stale)
		if err != nil {
			return err
		}
	}
	var stale = len(curr)

	log.Printf("{{ .Name }} - Cache initialised population added %d, updated %d, unchanged %d, stale %d", added, updated, unchanged, stale)
	resourceWatch, err := resource.Watch(v1.ListOptions{
		ResourceVersion: resourceList.ResourceVersion,
	})

	if ! kw.watchingStarted {
		close(kw.watching)
		kw.watchingStarted = true
	}

	ch := resourceWatch.ResultChan()
	for {
		select {
		case event := <-ch:
			var err error
			if event.Type == watch.Error {
				err = fmt.Errorf("Watch ended in error")
			} else {
				res, ok := event.Object.(*tp.{{ .Name }})
				log.Printf("{{ .Name }} - Received event type %s", event.Type)
				if !ok {
					err = fmt.Errorf("Watch error - object of unexpected type received")
				} else {
					copy := res.DeepCopy()
					kw.updateKind(copy)
					switch event.Type {
					case watch.Added:
						err = kw.Cache.Add(copy)
					case watch.Modified:
						err = kw.Cache.Add(copy)
					case watch.Deleted:
						err = kw.Cache.Delete(copy)
					}
				}
			}
			if err != nil {
				return err
			}
		case <-kw.stopchan:
			log.Printf("{{ .Name }} - Shutdown received")
			return nil
		}
	}
}

func (kw *{{ .Name }}Watcher) updateKind(o *tp.{{ .Name }}) {
	if o.TypeMeta.Kind == "" {
		o.TypeMeta.Kind = "{{ .Name }}"
	}
}
`))
