:toc:
:toc-placement!:

User stories describing functionality of EnMasse 1.0 and how to configure resource for those stories.

toc::[]

== Tenant Admin

=== Enable messaging for a namespace by creating a messaging tenant
=== Reference infra, plans and authentication services in different namespaces

To enable messaging in a Kubernetes namespace, a `MessagingTenant` resource must be created by the tenant admin.

* The `MessagingTenant` may reference a specific `MessagingInfra`, `MessagingPlan` and `AccessControlService`
that should be used for the namespace.
* If a plan, infra or accessControlService is not specified, a default will be selected based on the service admin configuration.
* If the `namespace` field of the reference is omitted, the namespace of the operator is assumed.
* The `MessagingTenant` must have a name set to `default`


```
apiVersion: enmasse.io/v1beta2
kind: MessagingTenant
metadata:
  name: default
  namespace: myapp
spec:
  infraRef:
    name: myinfra
    namespace: infra-space

  planRef:
    name: small
    namespace: plan-space

  accessControlServiceRef:
    name: corp-auth
    namespace: auth-space
```

Then apply this resource using the command line tools or the console. Once applied, the status
of the tenant can be checked by querying the API:

```
$ kubectl get messagingtenant -n myapp default
NAME      PHASE         AGE
default   Configuring   27s
```

---

=== Disable messaging for a namespace by deleting a messaging tenant

To disable messaging for a namespace, delete the `MessagingTenant` resource:

```
kubectl delete messagingtenant default -n myapp
```

NOTE: If there are still addresses and endpoints left in the namespace, the `MessagingTenant` will have the phase `Terminating` until they are removed.

---

=== CRUDLW a messaging address in a namespace where messaging is enabled

A tenant admin creates a `MessagingAddress` resource with the desired settings.

* An address may specify only a single type.
* An optional field `addressPlanRef` may reference a `MessagingAddressPlan`. If not set, a default will be used based on the service admin configuration.



==== Resource definition

```
apiVersion: enmasse.io/v1beta2
kind: MessagingAddress
metadata:
  name: myqueue
  namespace: myapp
spec:
  anycast: {}
  multicast: {}
  queue: {}
  topic: {}
  subscription:
    # References a MessagingAddress named mytopic with type topic.
    topic: mytopic

  # A system-wide address available on all brokers
  deadLetter: {}
status:
  phase: Pe
```

---

=== Ability to configure DLQ, expiry, forwarders etc. per address

* Queues that should be configured with a DLQ or ExpiryQueue should reference an address with type `deadLetter`.
* Forwarders may be configured for the queue (`in` and `out`), subscription (`out`) or deadLetter(`out`)) types.
* If the referenced DLQ does not exist, the status section of the address will provide an error message.


```
apiVersion: enmasse.io/v1beta2
kind: MessagingAddress
metadata:
  name: myqueue
  namespace: myapp
spec:
  queue:
    # Note: a queue 'mydlq' must exist!
    deadLetterQueue: admin-addr
    # Note: a queue 'myexpiry' must exist!
    expiryQueue: admin-addr

    # Forwarders require a MessagingConnector to exist, in this case one that is named 'remote1'.
    forwarders:
    - name: fwd1
      remoteAddress: remote1/queue1
      direction: in
status:
  phase: Pending | Configuring | Active | Failed | Terminating
  message: "Useful error message"
  # Type allows CLI tooling to show the type
  type: Anycast | Multicast | Queue | Topic | Subscription | DeadLetter

  # If a plan was configured, show the applied plan
  appliedPlanRef:
    name: myplan
    namespace: planspace

  conditions:
  - type: Scheduled
    status: "True"
    lastTransitionTime: 2020-......
```

---
=== CRUDLW a messaging endpoint in a namespace where messaging is enabled
=== Managing certificates for a messaging endpoint

Create a `MessagingEndpoint` resource with one of the supported types.

* Supported types are `cluster`, `route`, `ingress`, `loadBalancer` or `nodePort`.
* An endpoint can only be of a single type.
* Support protocols are AMQP, AMQPS (AMQP over TLS), AMQP-WS and AMQP-WSS (AMQP over secure websocket).
* For "Ingress" and "Route", only the AMQPS or AMQP-WSS maybe specified (not both!)
* Default protocols are defined in a `MessagingPlan` for a namespace. If the plan does not specify defaults, they will be:
** For `route` and `ingress`: AMQPS
** For `cluster`, `nodePort` and `loadBalancer`: AMQP,AMQPS

==== Resource definition

Example resource with all configuration knobs exposed for all types:

```
apiVersion: enmasse.io/v1beta2
kind: MessagingEndpoint
metadata:
  name: endpoint1
  namespace: myapp
spec:
  protocols:
  - AMQP
  - AMQPS
  - AMQP-WS
  - AMQP-WSS

  # Optional: Override generated hostname for endpoint. Clients must have the AMQP OPEN hostname set to this value.
  host: example.com

  # Optional: specify TLS configuration for endpoint.
  tls:
    # Selfsigned is default unless specified by a `MessagingPlan`.
    selfsigned: {}
    # OpenShift requests a service certificate signed by OpenShift service CA
    openshift: {}
    # External allows providing certificate externally. CN/SANs are validated against host
    external:
      cert: # Reuse structure from address space connector spec
      key: # Reuse structure from address space connector spec

  # Cluster type creates a on-cluster load balancer
  cluster: {}

  # NodePort type creates a nodePort service, exposing the application on an ephemeral port on all nodes.
  nodePort: {}

  # LoadBalancer type creates an external load balancer for this endpoint.
  loadBalancer:
    # Allow setting annotations on the service object that are specific to LoadBalancer implementations.
    annotations:
      aws-specific-annotation: value

  # Ingress type creates an Ingress resource
  ingress:
    # Optional: Allow configuring annotations specific to ingress controller implementations
    annotations: {}

  # Route type maps to OpenShift Route resource
  route:
    # Allows controlling the TLS termination of this route. Only supported for AMQP-WSS protocol.
    tlsTermination: passthrough | reencrypt

status:
  phase: Pending | Configuring | Active | Failed | Terminating
  message: "Useful error message"

  # Host set to auto-generated value
  host: messaging.example.com

  ports:
  - name: endpoint1-amqp
    port: 5672
    protocol: AMQP
  conditions:
  - type: FoundTenant
    status: "True"
    lastTransitionTime: 2020-......
  tls:
    selfsigned:
      ca.pem: <PEM VALUE>
```

==== Configure an in-cluster endpoint with TLS

The following resource will create a `cluster` endpoint with `AMQPS` protocol enabled using OpenShift-signed certs:

```
apiVersion: enmasse.io/v1beta2
kind: MessagingEndpoint
metadata:
  name: endpoint1
  namespace: myapp
spec:
  protocols:
  - AMQPS
  tls:
    openshift: {}
  cluster: {}
```

==== Configure an endpoint exposed as a route

The following resource will create a `route` endpoint with `AMQPS` protocol enabled overriding the hostname and certificate configuration.

```
apiVersion: enmasse.io/v1beta2
kind: MessagingEndpoint
metadata:
  name: endpoint1
  namespace: myapp
spec:
  tls:
    external:
      cert:
        valueFromSecret:
          name: messaging-cert
          key: tls.crt
      key:
        valueFromSecret:
          name: messaging-cert
          key: tls.key
  # Optional: Default selected
  protocols:
  - AMQPS
  host: messaging.example.com
  route: {}
```

==== Configure an endpoint exposed as a loadBalancer

```
apiVersion: enmasse.io/v1beta2
kind: MessagingEndpoint
metadata:
  name: endpoint1
  namespace: myapp
spec:
  tls: {}
  loadBalancer
    annotations: {}
```

---

=== CRUDLW a messaging connector in a namespace where messaging is enabled

Connectors are created by defining a resource of kind `MessagingConnector`.

* The connector name is taken from the `metadata.name` field and should be used as the prefix for any forwarders created on addresses.
* Resource is similar to what exists in `AddressSpace` `.spec.connectors`.

==== Resource definition:

```
apiVersion: enmasse.io/v1beta2
kind: MessagingConnector
metadata:
  name: conn1
  namespace: myspace
spec:
  endpointHosts:
  - host: example.com
    port: 5672
  role: route-container
  idleTimeout: 12
  maxFrameSize: 12345
  tls:
    caCert:
      value: <Base64-encoded PEM>
    clientCert:
      valueFromSecret:
        name: client-cert
    clientKey:
      valueFromSecret:
        name: client-cert
  credentials:
    username:
      value: myuser
    password:
      valueFromSecret:
        name: client-password
  addresses:
    - name: pat1
      pattern: queue*
```

== Service Admin

---

=== Define infra, plans and access control services in different namespaces

A `MessagingInfra`, `MessagingPlan`, and `AccessControlService` may be created in any
namespace where permissions is granted by the cluster admin. However, resources defined in namespaces not watched by the operator will not be processed.

---

=== CRUDLW an instance of messaging infrastructure shared between multiple messaging tenants

Create the following `MessagingInfra` to make the infrastructure shared between all namespaces on the cluster:

```
apiVersion: enmasse.io/v1beta2
kind: MessagingInfra
metadata:
  name: infra1
  namespace: enmasse-infra
spec: {}
```

Create the following `MessagingInfra` to make the infrastructure shared by a selection of namespaces based on their names:

```
apiVersion: enmasse.io/v1beta2
kind: MessagingInfra
metadata:
  name: infra1
  namespace: enmasse-infra
spec:
  selector:
    namespaces:
    - "ns1"
    - "ns2"
```

Create the following `MessagingInfra` to make the infrastructure shared by a selection of namespaces based on labels:

```
apiVersion: enmasse.io/v1beta2
kind: MessagingInfra
metadata:
  name: infra1
  namespace: enmasse-infra
spec:
  selector:
    namespaceSelector:
      matchLabels:
        environment: test
```

---

=== Restrict plans available to messaging tenants

When creating the plan, define a selector with the desired restrictions on which namespaces it can be referenced from.

```
apiVersion: enmasse.io/v1beta2
kind: MessagingPlan
metadata:
  name: myplan
  namespace: planspace
spec:
  # Selects which namespaces this tenant plans should be available for
  selector:
    # Restrict to specific namespaces
    namespaces:
     - ns1
     - ns2
    # Restrict to namespaces matching labels
    namespaceSelector:
      matchLabels:
        environment: production
```

=== Restrict address plans available to addresses

In the same way as for `MessagingPlan`, a `MessagingAddressPlan` may define a selector to restrict
which namespaces it can be referenced by.

```
apiVersion: enmasse.io/v1beta2
kind: MessagingAddressPlan
metadata:
  name: myplan
  namespace: planspace
spec:
  # Selects which namespaces this tenant plans should be available for
  selector:
    # Restrict to specific namespaces
    namespaces:
     - ns1
     - ns2
    # Restrict to namespaces matching labels
    namespaceSelector:
      matchLabels:
        environment: production
```


=== Specify default plans for messaging tenants

When creating the plan, define a selector with the desired namespaces it should be available for.

* The plan will automatically be the default for namespaces matching its selector.
* If multiple plans are overlapping the same namespace, the default will be the oldest plan (ordered by creationTimestamp)

```
apiVersion: enmasse.io/v1beta2
kind: MessagingPlan
metadata:
  name: myplan
  namespace: planspace
spec:
  selector:
    namespaceSelector:
      matchLabels:
        environment: dev
```

=== Specify default address plans for messaging tenants

When creating the plan, define a selector with the desired namespaces it should be available for.

* The plan will automatically be the default for addresses in the namespaces matching its selector.
* If multiple plans are overlapping the same namespace, the default will be the oldest plan (ordered by creationTimestamp)

```
apiVersion: enmasse.io/v1beta2
kind: MessagingAddressPlan
metadata:
  name: myplan
  namespace: planspace
spec:
  selector:
    namespaceSelector:
      matchLabels:
        environment: dev
```

=== Specify default endpoints and cert providers to be created for messaging tenants

Default endpoint configuration is specified in the `MessagingPlan` under the `default` field.

* The controller creates one `MessagingEndpoint` for each entry in the plan list
* The schema for each entry corresponds to the `spec` object in `MessagingEndpoint` with the following exceptions:
  * The `host` field is ignored and set to defaults

```
apiVersion: enmasse.io/v1beta2
kind: MessagingPlan
metadata:
  name: myplan
  namespace: planspace
spec:
  default:
    endpoints:
     - route: {}
       protocols:
       - AMQPS
       tls:
         openshift: {}
     - cluster: {}
        # Define which protocols are supported by the default endpoint
       protocols:
       - AMQP
```

=== Restrict which endpoint types and cert providers can be used for messaging tenants

Restricting allowed endpoint types and cert providers allow the service admin to control
exposure of messaging endpoints in a cluster. The `restrict.endpoints` field is used to restrict
which endpoint types and which protocols are allowed.

* `MessagingEndpoint` resources for tenants referencing this plan must exactly match one of the entries.
* The schema for each entry corresponds to the `spec` object in `MessagingEndpoint` with the following exceptions:
  * The `host` field is ignored and set to defaults

The following example will enforce `route` endpoints to use a specific certificate and require `cluster` endpoints to use unencrypted protocols.

```
apiVersion: enmasse.io/v1beta2
kind: MessagingPlan
metadata:
  name: myplan
  namespace: planspace
spec:
  restrict:
    endpoints:
     - route: {}
       protocols:
       - AMQPS
       tls:
         external:
           cert:
             valueFromSecret:
               name: external-certs
     - cluster: {}
        # Define which protocols are supported by the default endpoint
       protocols:
       - AMQP
```


=== Restrict how much memory and storage is consumed per messaging tenant

Create the following `MessagingPlan` to enforce limits:

```
apiVersion: enmasse.io/v1beta2
kind: MessagingPlan
metadata:
  name: plan1
  namespace: planspace
spec:
  broker:
    resources:
      requests:
        memory: 512Mi
        storage: 1Gi
      limits:
        memory: 1Gi
        storage: 10Gi
  router:
    resources:
      requests:
        connections: 10
      limits:
        connections: 100
```

=== Restrict how much memory and storage is consumed per address

Create the following `MessagingAddressPlan` to enforce limits for multiple address types:

* Multiple address types can be defined in the same plan
* If resource limit is not set - limit is not specified
* If resource request is not set - it equals the limit
* If resource is not set - no limits are specified

```
apiVersion: enmasse.io/v1beta2
kind: MessagingAddressPlan
metadata:
  name: plan1
  namespace: planspace
spec:
  queue:
    resources:
      requests:
        memory: 5Mi
        storage: 20Mi
      limits:
        memory: 10Mi
        storage: 30Mi
  topic:
    resources:
      limits:
        memory: 5Mi
        storage: 20Mi

```

NOTE: Allow `MessagingAddressPlan` to cover multiple address types in order to allow more flexible plan management.

=== Configure scaling of the routers based on the connection load and number of messaging tenants

=== Configure scaling of the brokers based on the queue and topic memory and storage usage

=== Configure per-user limits for connections, links, message size

=== Migrate tenant configuration and data from 1.5 to 2.0 (with downtime)
