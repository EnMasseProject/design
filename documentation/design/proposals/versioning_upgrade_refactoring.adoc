= Versioning and Upgrade Refactoring

== why

* Approach to upgrade is inconsistent.
 ** For addressspaces, upgrade triggered by the fact that major.minor version on the plan disagrees with the major.minor
    of the running software.   There is no way to trigger the upgrade path for a mirco increment.
 ** For authenticationservices and consoleservice the code follows the OLM framework reconcile pattern.  For the upgrade
    use-case this is functional but the code has no knowledge of the 'from' major/minor/mirco.  This may be an impediment
    if we ever need to handle more sophisticated upgrades.
 ** The addressspace's OAuth configuration becomes stale if the consoleservice is updated after the addressspace is created.   
* No easy way for the user to determine major/minor/micro of the product being run.
 ** The console displays a version - this is always an upstream version even in the downstream product.
 ** No mechanism to determine the version from a command line/API.
 ** (Downstream) No easy way to ensure that you are running a set of images from the same major/minor/micro release.
* Many configuration items exposed as environment variables in api-server/address-space-controller/enmasse-controller     
  deployments.  For Ansible/Bundle users configuration of these items is possible by a user (documentation is non existent).
  For OLM, the situation is worse as the environment variables are baked into the OLM manifest.
* Having three distinct install paths Ansible/Bundle/OLM increases the difficulty when reasoning about the defects in the
  product.
* Uninstall for OLM is broken (https://github.com/EnMasseProject/enmasse/issues/2863).

== what

=== Operator Responsible For Install

The enmasse-operator will be given the responsibilities to deploy the api-server, address-space-controller, and service-broker and associated services, routes, roles, rolebindings etc. 

It will also be responsible for reconciling the current state of those object against the desired state.

=== EnMasse CR

There will be an EnMasse CRD with an instance of this CR representing EnMasse itself.

The enmasse-operator will watch its own namespace for the creation of  the enmasse CR.  On its appearence, it will take care
of the deployment.  Conversely, if the CR is removed it will be removed.  This will go towards fixing #2863.

The CR's spec will carry the configuration items that are current expressed as environment variables on the enmasse-operator, api-server, address-space-controller.  The CR will also carry the major/minor/micro version number of the version of EnMasse that created the record.  The status section will expose the current version.

==

in the same namespace)
by creating an 
Add a enmasse CRD.  EnMasse will im


