# Proposal - Authentication and Authorization for 1.0

## Overview

1.0 will introduce a new Access Control Service.  This will replace the existing authentication services.
It will have responsibility for identity management and authorization for the messaging use-case.

For identity, it will have provision for:

* leverage an external identity provider (such as a LDAP provider),
* leverage an external AMQP SASL authentication endpoint (implementing the `authServicePlugin` interface),
* provide an internal identity provider (where users are represented by a kubernetes custom resources),
* utilize client auth (in collabration with the `MessagingEndpoint` and the Qpid Dispatch Router),
* utilise service account tokens for messaging authentication purposes, and
* provide an anonymous identity provider (SASL ANONYMOUS)

For authorization, authorization rules sourced from custom kubernetes resources will allow individual users, or
groups of users to be permissioned for sending to or receiving from address(es) within the namespace.

The Service Admin will be able to selectively enable/disable identity providers by configuring the Access Control Service
resource. This will allow EnMasse to conform to the identity management rules of a particular organisation.  For instance, it will be possible for the Access Control Service to be configured so that only the external LDAP is available, or that
service account and the external LDAP are available.

Each Messaging Tenant will be associated with exactly one Access Control Service. This can be done locally by a Tenant
Admin, or alternatively the Service Admin will be able to configure one or more Access Control Services centrally. Selectors will automatically associate an Access Control Service with the Tenants.

For the getting started use case, there will be a implict in-built default which will apply until the first Access Control
Service is defined by the Service Admin.  The in-built default will provide ANONYMOUS access with an allow all policy.

== Design overview

=== Compoenents

==== Access Control Server

An Access Control Server instance will provide identity management and authorization services to all the tenants of an instance of shared infrastructure.  The Access Control Server will be a stateless component that will be scaleable for
availability and performance.  It will be implemented in Go.

The Access Control Server will be created by EnMasse Operator according to configuration within the MessagingInfra object.

The Access Control Server will provide an AMQP SASL endpoint that implements `authServicePlugin` interface.

On each incoming AMQP connection, the Access Control Server will use TLS SNI will allow it to determine which
`AccessControlService` to apply when processing each authentication event.

The algorithm for processing each authentication event:

1. Router connects to the AMQP SASL endpoint associated with the router listener.
1. Access Control Server uses the SNI information to resolve the applicable `AccessControlService`
1. Access Control Service uses the configuration of the `AccessControlService` determine the avaiable SASL mechanism(s).
1. SASL-MECHANISMS performative flows the Client.
1. Client selects mechanism
1. SASL-INIT flows to the Access Control Server
1. SASL-CHALLENGE / SASL RESPONSE as necessary
1. Access Control Server calls out to the external authentication service / uses `MessagingUser` / `TokenReview` (as appropiate) to determine if the authentication is successful.
1. SASL-OUTCOME flows to the Client.
1. Access Control Server uses the `MessagingRole`, and `MessagingRoleBinding` to calculate the `address-authz`.
1. AMQP OPEN flows to the Router carrying the authorisation policy.

===== Provider Behaviour

====== External LDAP Provider

Allows the use of an Open Directory implementing the LDAP protocol to provide an identity and, optionally, group information.
The Access Control Server will perform a simple bind against the LDAP in order to determine the success or failure of the authentication.

Simple bind requires the plain text password from the client, so SASL PLAIN will be offered when this identity provider is used.

Later, support will be added for LDAP SASL.

====== External AMQP SASL Provider

Allows the use of an AMQP SASL authentication endpoint that implements the `authServicePlugin` protocol.  When this identity
provider is used, the Access Control Server acts a SASL proxy.  It will connect to the external provider and relay the
the AMQP SASL performatives to/from the client.

The response from the External AMQP SASL server must provides an `authenticated-identity`.  It may also provide
`groups` and may provide `address-authz`.  If the external server provides an `address-authz`, it will be ANDed with the `address-authz` calculated from the `MessagingRoles` and `MessagingRoleBindings`.

The SASL mechanisms offered when this identity provider are in use depend on the mechansims required by the External AMQP SASL server.

====== Internal Identity Provider

The Internal Identity Provider uses the `MessagingUser` resources are a identity/password database.

The password in the MessagingUser record will usually stored salted (defined by  https://tools.ietf.org/html/rfc5802). However
it will be possible for a request for authentication to arrive before the salting has taken place, to cater for this
case, the Internal Identity Provider will also accept plain passwords from the database.

This identity provider will offer SASL mechanism PLAIN and SCRAM-SHA-256.

====== Client Auth Identity Provider

For client auth, the identity is established during the TLS negotiation phase between Client and Router.  The router will
pass the established identity through the `authServicePlugin` to the Access Control Server via the SASL EXTERNAL mechanism
via the link:https://tools.ietf.org/html/rfc4422#appendix-A[authz-id-string].  (TODO: check Router behaviour).

This identity provider will offer SASL mechanism EXTERNAL.

====== Service Account Identity Provider

For the Service Account provider, the client passes the Service Account's bearer token as a password and a special user-id
`@@serviceaccount@@`. The Access Control Server will perform a `TokenReview` to check the token's validity and retrieve the user username. 

This identity provider will offer SASL mechanisms PLAIN, XOAUTH2 (Obsolete), link:https://tools.ietf.org/html/rfc7628[OAUTHBEARER]

====== Anonymous Identity Provider 

For the Anonymous Provider, the SASL mechnism ANONYMOUS will be used.

===== Behaviour Without AccessControlService

To support the simple getting started use case, if there are no `AccessControlService` defined in the infra namespace,
the system will behaves as if there is an `AccessControlService` with the anonymous identity provider defined.  For
authorization, it will be as if an authorisation policy grant all access to all addresses exists.

As soon as an `AccessControlService` is defined in the infra namespace, the default described here becomes unavailable for
use.

===== Go AMQP server implementation

The Access Control Server's Go AMQP server requirements are quite limited.   It does not require a full-blown AMQP server
implementation.  It is sufficient to handle the AMQP SASL performatives and the AMQP Open/Close performatives.  This can
be implemented within the Access Control Server code-base.  It will borrow codec implementation from Azure AMQP client.

==== EnMasse Operator

The EnMasse Operator will act as the controller for `AccessControlService`, `MessagingUser`, `MessagingRole`, and `MessagingRoleBinding` resources and be responsible for maintaintence of the status sections.  For `MessagingUser`
resources it will be responsible for salting passwords. 

The EnMasse operator will watch for `MessagingTenants` resources.  For each it will and define a Kubernetes service
exposing the AMQP SASL endpoint of the Access Control Servcie  The MessagingInfra controller will configure a router listener/authServicePlugin _per tenant_  with a reference to the correct  AMQP SASL endpoint.

==== Messaging Client

When the messaging clients authenticate, in some cases the username must be qualified with an `@DOMAIN` suffix.  The qualification must be used when authenticatiing with an identity from an external LDAP or external AMQP SASL server.

For theinternal identity provider, the domain suffix may be omitted.  The service accounts, the username is always `@@serviceaccount@@`.  For client auth, the identity is the common name from the certificate.

==== Qpid Dispatch Router

This proposal reuses the existing `authServicePlugin` of the Qpid Dispatch Router unchnaged.

=== Resources

The new API will consist of the following types at the infrastructure level:

* `AccessControlService`: used to define an instance of an accesss control service. The `AccessControlService` will define
the parameters to establish connection with external identity provider (if any).  Selectors will be to configure to which namespaces it should be applied.

* Configuration provided by `MessagingInfra` will define the Access Control Server deployment.

At the tenant level:

* `MessagingTennant`: can be used to specify a specific `AccessControlService` to be used for the tenant.

* `MessagingUser`: used with the internal identity source to provide a messaging username/password pairing.  The password will be stored in the resource a secure fashion.  `MessagingUser` is scoped to the messaging tenant. It cannot
be used to access any other namespace apart from the only in which it exists.

* `ServiceAccount`: a bearer token of a  `ServiceAccounts` can be used to authenticate to the namespace for messaging.  The service account must exist within the namespace of the messaging tenant.

* `MessagingRole`: define access to one or more addresses.  Its design will be analogous to the kubernetes role object but will not have any relation to kubernetes `roles` or `clusterroles`.

* `MessagingRoleBinding`: grants permission for messaging within the namespace.  A MessagingRoleBinding may reference any `MessagingRole` in the same namespace and any subject produced by the identity providers (user or group).  Its design will be analogous to the kubernetes rolebinding object but will not have any relation to kubernetes `rolebindings` or `clusterrolebindings`.

=== Resources

==== AccessControlService

The `AccessControlService` used to define an instance of an accesss control service.  It allows the configuration the external
identity providers and gives the ability to disable the internal identity providers.

When the messaging client authenticates the domain part must be provided as part of the SASL username.  An exception
is made for the client authentication provider and the anonymous provider.

The `AccessControlService` has a selector for namespaces that should use this AccessControlService by default.  This selector
is ANDed with the selector of the `MessagingInfra` itself. The `MessagingTenant` may override the the `AccessControlService` by specifying the service's name and namespace.  An annotation of the `AccessControlService` will be used to prevent
overriding.

Example:

```
apiVersion: enmasse.io/v1beta2
kind: AccessControlService
metadata:
  name: myaccesscontrol1
spec:
  identityProviders:
    ldap:
      enabled: boolean
      domain: # RFC 1123 convetions (DNS subdomain)
      host:
      port:
      tls: # borrow structure from connector (trust, client cert)
      credentials: # borrow structure from connector
      searchContext:
      searchFilter:
      groupAttributeName: # more fields required to flexibly support LDAP groups.
    external:
      enabled: boolean
      domain: RFC 1123 convetions (DNS subdomain)
      host:
      port:
      tls: # borrow structure from connector (trust, client cert)
      credentials: # borrow structure from connector
    internal:
      enabled: boolean
    clientAuth:
      enabled: boolean
    serviceAccount:
       enabled: boolean
    anonymous:
       enabled: boolean

  # Allows specifying a selector for namespaces that should use this accesscontrol by default.
  namespaceSelector:
    matchLabels:
      type: messaging
status:
  phase: Active
```

==== MessagingInfra

Configuration provided by `MessagingInfra` will define the Access Control Server deployment.

```
accessControl:
    replicas: <integer>
```

==== MessagingTennant

A `MessagingTennant` can explictly reference a AccessControlService in order to override default configuration provided by the
Service Admin.

```
accessControlService:
    name: myaccesscontrol1
    namespace: custom
```

==== MessagingUser

`MessagingUser` exists to supports the internal identity source.  It allows a Tenant Admin to define a user/password that
may connect for messaging.

The stored password will be the Salted Password defined by  https://tools.ietf.org/html/rfc5802. 
The controller will detect newly created MessagingUser resource and automatically salt plain text passwords.

In this first version, there will be no provision for password policies (constitunency rules, aging etc).

```
apiVersion: enmasse.io/v1beta2
kind: MessagingUser
metadata:
  name: myuser
  namespace: mynamespace
spec:
  password: {SCRAMSHA256}_saltedpassword_
```

==== ServiceAccount

The bearer token of a `ServiceAccounts` can be used to authenticate to the namespace for messaging.  The service accoun
must exist within the namespace of the messaging tenant.

==== MessagingRole

`MessagingRole` is used with `MessagingRoleBinding` to define authorisation rules.  The `MessagingRole` allows
one or more address patterns to the associated with the verbs "send" and/or "receive".   Permissions are purely additive (there are no “deny” rules).  There is no referential integrity enforced between the address prefixes and the
messaging addresses.

```
apiVersion: enmasse.io/v1beta2
kind: MessagingRole
metadata:
  name: myrole
  namespace: mynamespace
spec:
- addressPatterns: ["alpha*", "beta", "gamma"]
  verbs: ["send", "receive"]
```

==== MessagingRoleBinding

The `MessagingRoleBinding` provides the linkage between the user and the `MessagingRole`.

There is no referential integrity enforced between the referenced messaging users or service accounts and the `MessagingUser` or `ServiceAccount` themselves.

For the subject references, the following will be used:

1.  `ServiceAccount` - the subject will follow the Kubernetes conventions for service accounts
  - `system:serviceaccount:<namespace>:<serivceaccount name>` (refers the named service account),
  - `system:serviceaccount:<namespace>` (refers to all serviceaccounts in the namespace), or
  - `system:serviceaccount`  (refers to all serviceaccounts system wide)
1. `MessagingUser` - the subject will follow the conventions for service accounts, with the exception that the system
   wide form is disallowed.  The namespace must refer to the namespace of this tenant.
  - `enamsse.io:messaginguser:<namespace>:<name>` (refers the named messaginguser),
  - `enamsse.io:messaginguser:<namespace>` (refers to all messagingusers in the namespace)
1. `Subject` - a user or group subject belonging to an External, TLS Client Auth or Anonymous Identity Provider.
  - `enamsse.io:<domain>:<namespace>:<name>` (refers to subject _name_ from the provider with the given domain)
  - `system:unauthenticated` - corresponds to the unauthenticated identity from the the anonymous identity provider.

```
apiVersion: enmasse.io/v1beta2
kind: MessagingRoleBinding
metadata:
  name: myapps1-permissions
  namespace: mynamespace
subjects:
- kind: Subject
  name: system:serviceaccount:myns:myappuser # refers to ServiceAccount myapp in myns 
- kind: Subject
  name: enamsse.io:messaginguser:myns:myappuser  # refers to MessagingUser myappuser in myns 
- kind: Subject
  name: enamsse.io:ldap.mycompany.com:myns:bill
- kind: Subject
  name: enamsse.io:tlsclientauth:myns:cn=John Doe,dc=example,dc=com
messagingRoleRef:
  name: myrole
```

=== Ensuring Uniquely Identifiable Identities in the Router Logs
 
As the Routers are shared by all the Tenants, it is possible that two or more tenants could define an identities with
colliding names.  In order to ensure that activity of the users is attributable from the routers logs, the 
`preferred_username` field of the `address-authz` response will return a qualified name:

1. External LDAP / External AMQP SASL `enamsse.io:ldap.mycompany.com:myns:bill`
1. Internal Provider `enamsse.io:messaginguser:myns:myappuser`
1. Service Account `system:serviceaccount:myns:myapp`
1. TLS Client Auth - enamsse.io:tlsclientauth:myns:cn=John Doe,dc=example,dc=com
1. Anonynous - `system:unauthenticated`

=== Metrics

The AccessControlService will expose a Prometheus endpoint will the following metrics:

1. `auth_requests_total{namespace="", domain="", sasl_outcome=""}`
1. `auth_requests_duration_seconds{namespace="", domain="", sasl_outcome="", le=<buckets>}`


https://github.com/EnMasseProject/enmasse/issues/4106
https://github.com/EnMasseProject/enmasse/blob/master/documentation/design/proposals/shared-infrastructure.adoc
https://qpid.apache.org/releases/qpid-dispatch-master/man/qdrouterd.conf.html#_authserviceplugin
